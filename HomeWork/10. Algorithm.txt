1. 선형정렬 3종의 구현원리 조사
	1-1 선택 정렬(Selection Sort)
	선택정렬은 현재위치에 들어갈 값을 찾아 정렬하는 배열이다.현재위치	에
	저장 될 값의 크기나 작냐, 크냐에 따라 최고 선택 정렬(Min-Selection Sort)와
	최대 선택 정렬(Max-Selection Sort)로 구분 할 수 있다.
	-최소 선택 정렬은 오름차수능로 정렬될 것이고, 최대 선택 정렬은 내림차순으로
	정렬될 것이다.
		*원리*
		1-1-1 정렬 되지 않은 인덱스의 맨 앞에서부터, 이를 포함한 그 이후의 배열값 중
		가장 작은 값을 찾아간다.(정렬되지 않은 인덱스의 맨 앞은, 초기 입력에서는 배열의 시작위치일 것이다.)
		1-1-2 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.
		1-1-3 다음 인덱스에서 위 과정을 반복해준다.

	1-2 삽입 정렬(Insertion Sort)
	삽입 정렬은 현쟈 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아,
	그 위치에 삽입하는 배열 알고리즘이다.
		*원리*
		1-2-1 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장해주고,
		비교 인덱스를 현재 인덱스 -1로 잡는다.
		1-2-2 별도로 저장해 둔 삽입을 위한 변수과, 비교 인덱스의 배열 값을 비교한다.
		1-2-3 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고,
		비교 인덱스를 -1하여 비교를 반복한다.
		1-2-4 만약 삽입 변수가 더 크면, 비교 인덱스 +1에 삽입 변수를 저장한다.

	1-3 버블 정렬(Bubble Sort)
	버블 정렬은 매번 연속된 두개의 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법이다.
	오름차순으로 정렬하고자 할 경우, 비교시마다 큰 값이 뒤로 이동하여, 1바퀴 돌 시
	가장 큰 값이 맨 뒤에 저장된다. 맨 마지막에는 비교하는 수들 중 가장 큰 값이 저장 되기 때문에,
	(전체 배열의 크기 - 현재까지 순환한 바퀴 수)만큼만 반복해주면 된다.
		*원리*
		1-3-1 삽입 정렬은 두 번째 인덱스부터 시작하낟. 현재 인ㅇ덱스 값과, 바로 이전의
		인덱스 값을 비교한다.
		1-3-2 만약 이전의 인덱스가 더 크면, 현재 인덱스와 바꿔준다.
		1-3-3 현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.
		1-3-4 이를 (전체 배열의 크기-현재까지 순환한 바퀴 수)만큼 반복한다.
	



2. 분할정복정렬(Divide and Conquer) 3종의 구현원리 조사
분할정복정렬 : 분할 정복(Divide and Conquer)방식으로 설계된 알고리즘이다.
분할 정복은 큰 문제를 반으로 쪼개 문제를 해결해 난가는 방식으로

	2-1 합병 정렬(Merge Sort)
	합병 정렬은 분할 정복(Divide and Conquer)방식으로 설계된 알고리즘이다.
	분할 정복은 큰 문제를 반으로 쪼개 문제를 해결해 난가는 방식으로, 
	(1)분할은 배열의 크기가 1보다 작거나 같을 때 까지 반복한다. 입력으로 하나의 배열을 받고,
	연산 중에 두개의 배열로 계속 쪼게 나간 뒤, 합치면서 정렬해 최후에는 하나의 정렬을 출력한다.
	(2)합병은 두 개의 배열을 비겨하여, 기준에 맞는 값을 다른 배열에 저장해 나간다.
	오름차순의 경우 배열A, 배열B를 비교하여 A에 있는 값이 더 작다면 새 배열에 저장해주고
	A인덱스를 증가킨 후 A,B의 반복을 진행한다.
	(3)이는 A나 B중 하나가 모든 배열값들을 새 배열에 저장할 때 까지 반복하며, 전부 다
	저장하지 못한 배열의 값들은 모두 새 배열의 값에 저장해준다.
		*원리* (분할 후, 합병)
		(분할)
		2-1-1 현재 배열을 반으로 쪼갠다. 배열의 시작 위치와, 종료위치를 입력받아 둘을 더한 후
		2를 나눠 그 위치를 기준으로 나눈다.
		2-1-2 이를 쪼갠 배열의 크기가 0이거나 1일때 까지 반복한다.
		(합병)
		2-1-3 두 배열 A,B의 크기를 비교한다. 각각의 배열의 현재 인덱스를 i,j로 가정하자.
		2-1-4 i에는 A배열의 시작 인덱스를 저장하고, j에는 B배열의 시작 주소를 저장한다.
		2-1-5 A[i]와 B[j]를 비교한다. 오름차순의 경우 이중에 작은 값을 새 배열C에 저장한다.
			  A[i]가 더 컸다면 A[i]의 값을 배열 C에 저장해주고, i의 값을 하나 증가시켜준다.
		2-1-6 이를 i나 j둘중 하나가 각자 배열의 끝에 도달할 때 까지 반복한다.
		2-1-7 끝까지 저장을 못한 배열의 값을, 순서대로 전부 다 C에 저장한다.
		2-1-8 C배열을 원래의 배열에 저장해준다.

	2-2 퀵 정렬(Quick Sort)
	pivot point라고하는 기준이 되는 값을 하나 설정하는데, 이 값을 기준으로 작은 값은 왼쪽,
	큰값은 오른쪽으로 옮기는 방식으로 정렬을 진행한다. 이를 반복하여 분할된 배열의
	크기가 1이 되면 배열이 모두 정렬 된 것이다.
		*원리*
		2-2-1 pivot pojnt로 잡을 배열의 값 하나를 정한다. 보통 맨 앞이나 맨 뒤,
		혹은 전체 배열 값중 중간값이나 랜덤 값으로 정한다.
		2-2-2 분할을 진행하기에 앞서, 비교를 진행하기 위해 가장 왼쪽 배열의 인덱스를 저장하는
		left변수, 가장 오른쪽 배열의 인덱스를 저장한 right변수를 생성한다.
		2-2-3 right부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며.
		비교한 배열값이 pivot point보다 크면 right를 하나 감소시키고 비교를 반복한다.
		pivot point보다 작은 배열 값을 찾으면, 반복을 중단시킨다.
		2-2-4 그 다음 left부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며.
		비교한 배열값이 pivot point보다 작으면 left를 하나 증가시키고 비교를 반복한다.
		pivot point보다 큰 배열 값을 찾으면, 반복을 중지한다.
		2-2-5 left 인덱스의 값과 right 인덱스의 값을 바꿔준다.
		2-2-6 3,4,5 과정을 left < right가 만족할 때 까지 반복한다.
		2-2-7 위 과정이 끝나면 left의 값과 pivot point를 바꿔준다.
		2-2-8 맨 왼쪽부터 left - 1까지, left + 1 부터 맨 오른쪽까지로 나눠 퀵 정렬을 반복.

	2-3 힙정렬 (Heap sort)
	힙은 완전 이진 트리 구조를 가진 힙 트리 구조를 이용하는 정렬방법며,
    이 힙의 특성을 이용하여 정렬하는 것이 힙정렬(Heap sort)이다.
		*원리*
		2-3-1 


3. 분할정복정렬 3종의 원리에 의한 특징 조사
   (힙정렬 특징, 병합정렬 특징, 퀵정렬 특징)

   3-1 힙정렬 특징
   시간복잡도가 O(nlogn)인 정렬 알고리즘 중에서는 부가적인
   메모리가 전혀 필요없다는 게 큰 장점인 정렬 방식입니다.

   3-2 병합정렬 특징
   안정성이 있여 상당히 좋은 성능을 나타냅니다.
   하나 큰 결점이 있다면 공간이 많이 필요하다는 점입니다.
   정렬을 하기 위해서는 데이터 전체 크기만한 메모리가 더 필요합니다.

   3-3 퀵정렬 특징
   가장 많이 사용되는 정렬법이나 안정성이 떨어진다는 단점이 있습니다.

                        <시간복잡도>

                힙         병합        퀵
Bast         O(nlogn)   O(nlogn)   O(nlogn)
Worst        O(nlogn)   O(nlogn)      n^2

